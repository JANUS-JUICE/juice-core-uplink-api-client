{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"juice-core-uplink-api-client","text":"<p>Documentation: https://JANUS-JUICE.github.io/juice-core-uplink-api-client</p> <p>Source Code: https://github.com/JANUS-JUICE/juice-core-uplink-api-client</p> <p>PyPI: https://pypi.org/project/juice-core-uplink-api-client/</p> <p>A client library for accessing Juice Core Uplink API</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install juice-core-uplink-api-client\n</code></pre>"},{"location":"#usage-example","title":"Usage example","text":"<p>First, create a client:</p> <pre><code>from juice_core import SHTRestInterface\ni = SHTRestInterface()\n</code></pre> <p>and access the list of available plans on the server:</p> <pre><code>i.plans()\n</code></pre> <p>will output a pandas dataframe with the list of plans (just some here):</p> trajectory name mnemonic is_public created id author description refine_log ptr_file 0 CREMA_3_0 CASE4 CASE4 True 2021-03-04 13:29:58.835199 17 rlorente Demonstration Case 4 1 CREMA_5_0 CREMA_5_0_OPPORTUNITIES_v0 CREMA_5_0_OPPORTUNITIES_v0 True 2021-08-26 09:12:06.767139 31 cvallat 1st run opf opportunities generation (UC22), based on existing definitions of oppportunities (inherited from crema 3_0) https://juicesoc.esac.esa.int/rest_api/file/trajectory%23CREMA_5_0.ptx/ 2 CREMA_5_0 CREMA_5_0_OPPORTUNITIES_v1 CREMA_5_0_OPPORTUNITIES_v1 True 2021-10-04 13:49:49.262682 36 cvallat Added two opportunities for JMAG_CALROL for the last 2 perijoves before JOI (PJ69 not considered since too clsoe to GoI for observations to take place --&gt; MPAD rule) https://juicesoc.esac.esa.int/rest_api/file/trajectory%23CREMA_5_0.ptx/ 3 CREMA_5_0 CREMA_5_0_OPPORTUNITIES_v2 CREMA_5_0_OPPORTUNITIES_v2 True 2021-10-05 07:24:07.742653 37 cvallat Modified GANYMEDE_GM opportunity around 3G3 for WG3 prime allocation (1 hour centered at CA) https://juicesoc.esac.esa.int/rest_api/file/trajectory%23CREMA_5_0.ptx/ <p>You can also directly interact with the underalying <code>juice-core-uplink-api-client</code> module:</p>"},{"location":"#development","title":"Development","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.10+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github Pages page automatically as part each release.</p>"},{"location":"#releasing","title":"Releasing","text":""},{"location":"#manual-release","title":"Manual release","text":"<p>Releases are done with the command, e.g. incrementing patch:</p> <pre><code>poetry run just bump patch\n# also push, of course:\ngit push origin main --tags\n</code></pre> <p>this will update the changelog, commit it, and make a corresponding tag.</p> <p>as the CI is not yet configured for publish on pypi it can be done by hand:</p> <pre><code>poetry publish --build\n</code></pre>"},{"location":"#automatic-release-to-be-fixed","title":"Automatic release - to be fixed","text":"<p>Trigger the Draft release workflow (press Run workflow). This will update the changelog &amp; version and create a GitHub release which is in Draft state.</p> <p>Find the draft release from the GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatting (<code>ruff format</code>), linters (e.g. <code>ruff</code> and <code>mypy</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This project was generated using a fork of the wolt-python-package-cookiecutter template.</p>"},{"location":"api_docs/","title":"API documentation","text":"<p>This module provides the core functionality of the Juice Core Uplink API Client in a more convenient way than the generated code.</p> <p>May functionalities are not yet implemented, but some are.</p>"},{"location":"api_docs/#juice_core.SHTRestInterface","title":"<code>SHTRestInterface</code>","text":""},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface","title":"<code>SHTRestInterface</code>","text":"<p>Main entry point for interacting with the Juice Core Uplink API</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@define(auto_attribs=True, eq=False)\nclass SHTRestInterface:\n    \"\"\"\n    Main entry point for interacting with the Juice Core Uplink API\n    \"\"\"\n\n    client: Client | None = None\n    timeout: float = 40.0\n\n    def __attrs_post_init__(self):\n        if not self.client:\n            self.client = Client(DEFAULT_URL)\n        # self.client.timeout = self.timeout\n\n    @cache\n    @pandas_convertable\n    def pcw(self):\n        return get_pcw.sync(client=self.client)\n\n    @cache\n    @pandas_convertable\n    def pcw_by_mnemonic(self, mnemonic: str):\n        return get_pcw_by_mnemonic.sync(client=self.client, mnemonic=mnemonic)\n\n    @cache\n    @pandas_convertable(time_fields=[\"created\"])\n    def plans(self):\n        \"\"\"Retrieve all the plans available on the endpoint\"\"\"\n        return get_plan.sync(client=self.client)\n\n    def plan_id_by_name(self, name):\n        \"\"\"Retrieve the plan id from the plan name\"\"\"\n        for plan in self.plans(as_pandas=False):\n            if plan.name.lower().strip() == name.lower().strip():\n                log.debug(f\"Plan {name} has id {plan.id}\")\n                return plan.id\n\n        log.warning(f\"No plan with name {name} found\")\n        return None\n\n    @cache\n    @pandas_convertable(time_fields=[\"start\", \"end\"])\n    def plan_segments(self, plan_id_or_name):\n        \"\"\"Retrieve the segments of a plan\"\"\"\n        plan = self.plan(plan_id_or_name, as_pandas=False)\n        return plan.segments\n\n    @cache\n    @pandas_convertable(time_fields=[\"start\", \"end\"])\n    def engineering_segments(self, trajectory=DEFAULT_TRAJECTORY) -&gt; pd.DataFrame:\n        \"\"\"Retrieve the engineering segments for a mnemonic\"\"\"\n        return get_trajectory_engineering_segments_by_mnemonic.sync(\n            mnemonic=trajectory,\n            client=self.client,\n        )\n\n    @cache\n    @pandas_convertable\n    def plan(self, plan_id_or_name):\n        \"\"\"Retrieve the plan from the plan id or name\"\"\"\n        if isinstance(plan_id_or_name, str):\n            plan_id_or_name = self.plan_id_by_name(plan_id_or_name)\n\n        return get_plan_by_id.sync(plan_id_or_name, client=self.client)\n\n    @cache\n    @pandas_convertable\n    def known_series(self, trajectory=DEFAULT_TRAJECTORY):\n        \"\"\"Retrieve all the series available on the endpoint\"\"\"\n        return get_trajectory_series_by_mnemonic.sync(\n            client=self.client,\n            mnemonic=trajectory,\n        )\n\n    @cache\n    @pandas_convertable(is_timeseries=True)\n    def series(\n        self,\n        series_name,\n        trajectory=DEFAULT_TRAJECTORY,\n        start=DEFAULT_START,\n        end=DEFAULT_END,\n    ):\n        \"\"\"Retrieve a serie from the endpoint\"\"\"\n\n        q = {\n            \"start\": str(start),\n            \"end\": str(end),\n            \"trajectory\": trajectory,\n            \"series\": series_name,\n        }\n\n        body = json.dumps(q)\n        return get_series.sync(client=self.client, body=body)\n\n    def series_multi_(\n        self,\n        series_names,\n        trajectory=DEFAULT_TRAJECTORY,\n        start=DEFAULT_START,\n        end=DEFAULT_END,\n    ):\n        loop = asyncio.get_event_loop()\n        coroutine = self.series_multi(\n            series_names,\n            trajectory=trajectory,\n            start=start,\n            end=end,\n        )\n        return loop.run_until_complete(coroutine)\n\n    def series_multi(\n        self,\n        series_names,\n        trajectory=DEFAULT_TRAJECTORY,\n        start=DEFAULT_START,\n        end=DEFAULT_END,\n    ):\n        \"\"\"Retrieve multiple series from the endpoint\"\"\"\n        out = []\n        for series_name in series_names:\n            q = {\n                \"start\": str(start),\n                \"end\": str(end),\n                \"trajectory\": trajectory,\n                \"series\": series_name,\n            }\n\n            body = json.dumps(q)\n            got = get_series.asyncio(client=self.client, body=body)\n            out.append(got)\n\n        return asyncio.gather(*out)\n\n    @cache\n    @pandas_convertable\n    def event_types(self, trajectory=DEFAULT_TRAJECTORY):\n        \"\"\"Retrieve all the events applicable for a trajectory\"\"\"\n        return get_trajectory_event_by_mnemonic.sync(\n            client=self.client,\n            mnemonic=trajectory,\n        )\n\n    @cache\n    def segment_definition(self, mnemonic):\n        return get_segment_definition_by_mnemonic.sync(\n            client=self.client,\n            mnemonic=mnemonic,\n        )\n\n    @pandas_convertable\n    def segment_definitions(self, mnemonics: list[str]):\n        return [self.segment_definition(m) for m in mnemonics]\n\n    @cache\n    @pandas_convertable(time_fields=[\"start\", \"end\"])\n    def events(\n        self,\n        mnemonics: list[str] | str = [],\n        trajectory: str = DEFAULT_TRAJECTORY,\n        start=DEFAULT_START,\n        end=DEFAULT_END,\n    ):\n        \"\"\"Retrieve events of a given type from the endpoint\"\"\"\n        if isinstance(mnemonics, str):\n            mnemonics = [mnemonics]\n\n        if len(mnemonics) == 0:\n            types = self.event_types(trajectory=trajectory, as_pandas=False)\n            mnemonics = [m.mnemonic for m in types]\n            log.info(f\"Retrieving all known events {mnemonics}\")\n\n        q = {\n            \"start\": str(start),\n            \"end\": str(end),\n            \"trajectory\": trajectory,\n            \"mnemonics\": mnemonics,\n        }\n\n        body = json.dumps(q)\n        return get_events.sync(client=self.client, body=body)\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.engineering_segments","title":"<code>engineering_segments(trajectory=DEFAULT_TRAJECTORY) -&gt; pd.DataFrame</code>  <code>cached</code>","text":"<p>Retrieve the engineering segments for a mnemonic</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable(time_fields=[\"start\", \"end\"])\ndef engineering_segments(self, trajectory=DEFAULT_TRAJECTORY) -&gt; pd.DataFrame:\n    \"\"\"Retrieve the engineering segments for a mnemonic\"\"\"\n    return get_trajectory_engineering_segments_by_mnemonic.sync(\n        mnemonic=trajectory,\n        client=self.client,\n    )\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.event_types","title":"<code>event_types(trajectory=DEFAULT_TRAJECTORY)</code>  <code>cached</code>","text":"<p>Retrieve all the events applicable for a trajectory</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable\ndef event_types(self, trajectory=DEFAULT_TRAJECTORY):\n    \"\"\"Retrieve all the events applicable for a trajectory\"\"\"\n    return get_trajectory_event_by_mnemonic.sync(\n        client=self.client,\n        mnemonic=trajectory,\n    )\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.events","title":"<code>events(mnemonics: list[str] | str = [], trajectory: str = DEFAULT_TRAJECTORY, start=DEFAULT_START, end=DEFAULT_END)</code>  <code>cached</code>","text":"<p>Retrieve events of a given type from the endpoint</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable(time_fields=[\"start\", \"end\"])\ndef events(\n    self,\n    mnemonics: list[str] | str = [],\n    trajectory: str = DEFAULT_TRAJECTORY,\n    start=DEFAULT_START,\n    end=DEFAULT_END,\n):\n    \"\"\"Retrieve events of a given type from the endpoint\"\"\"\n    if isinstance(mnemonics, str):\n        mnemonics = [mnemonics]\n\n    if len(mnemonics) == 0:\n        types = self.event_types(trajectory=trajectory, as_pandas=False)\n        mnemonics = [m.mnemonic for m in types]\n        log.info(f\"Retrieving all known events {mnemonics}\")\n\n    q = {\n        \"start\": str(start),\n        \"end\": str(end),\n        \"trajectory\": trajectory,\n        \"mnemonics\": mnemonics,\n    }\n\n    body = json.dumps(q)\n    return get_events.sync(client=self.client, body=body)\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.known_series","title":"<code>known_series(trajectory=DEFAULT_TRAJECTORY)</code>  <code>cached</code>","text":"<p>Retrieve all the series available on the endpoint</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable\ndef known_series(self, trajectory=DEFAULT_TRAJECTORY):\n    \"\"\"Retrieve all the series available on the endpoint\"\"\"\n    return get_trajectory_series_by_mnemonic.sync(\n        client=self.client,\n        mnemonic=trajectory,\n    )\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.plan","title":"<code>plan(plan_id_or_name)</code>  <code>cached</code>","text":"<p>Retrieve the plan from the plan id or name</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable\ndef plan(self, plan_id_or_name):\n    \"\"\"Retrieve the plan from the plan id or name\"\"\"\n    if isinstance(plan_id_or_name, str):\n        plan_id_or_name = self.plan_id_by_name(plan_id_or_name)\n\n    return get_plan_by_id.sync(plan_id_or_name, client=self.client)\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.plan_id_by_name","title":"<code>plan_id_by_name(name)</code>","text":"<p>Retrieve the plan id from the plan name</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>def plan_id_by_name(self, name):\n    \"\"\"Retrieve the plan id from the plan name\"\"\"\n    for plan in self.plans(as_pandas=False):\n        if plan.name.lower().strip() == name.lower().strip():\n            log.debug(f\"Plan {name} has id {plan.id}\")\n            return plan.id\n\n    log.warning(f\"No plan with name {name} found\")\n    return None\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.plan_segments","title":"<code>plan_segments(plan_id_or_name)</code>  <code>cached</code>","text":"<p>Retrieve the segments of a plan</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable(time_fields=[\"start\", \"end\"])\ndef plan_segments(self, plan_id_or_name):\n    \"\"\"Retrieve the segments of a plan\"\"\"\n    plan = self.plan(plan_id_or_name, as_pandas=False)\n    return plan.segments\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.plans","title":"<code>plans()</code>  <code>cached</code>","text":"<p>Retrieve all the plans available on the endpoint</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable(time_fields=[\"created\"])\ndef plans(self):\n    \"\"\"Retrieve all the plans available on the endpoint\"\"\"\n    return get_plan.sync(client=self.client)\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.series","title":"<code>series(series_name, trajectory=DEFAULT_TRAJECTORY, start=DEFAULT_START, end=DEFAULT_END)</code>  <code>cached</code>","text":"<p>Retrieve a serie from the endpoint</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>@cache\n@pandas_convertable(is_timeseries=True)\ndef series(\n    self,\n    series_name,\n    trajectory=DEFAULT_TRAJECTORY,\n    start=DEFAULT_START,\n    end=DEFAULT_END,\n):\n    \"\"\"Retrieve a serie from the endpoint\"\"\"\n\n    q = {\n        \"start\": str(start),\n        \"end\": str(end),\n        \"trajectory\": trajectory,\n        \"series\": series_name,\n    }\n\n    body = json.dumps(q)\n    return get_series.sync(client=self.client, body=body)\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.SHTRestInterface.series_multi","title":"<code>series_multi(series_names, trajectory=DEFAULT_TRAJECTORY, start=DEFAULT_START, end=DEFAULT_END)</code>","text":"<p>Retrieve multiple series from the endpoint</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>def series_multi(\n    self,\n    series_names,\n    trajectory=DEFAULT_TRAJECTORY,\n    start=DEFAULT_START,\n    end=DEFAULT_END,\n):\n    \"\"\"Retrieve multiple series from the endpoint\"\"\"\n    out = []\n    for series_name in series_names:\n        q = {\n            \"start\": str(start),\n            \"end\": str(end),\n            \"trajectory\": trajectory,\n            \"series\": series_name,\n        }\n\n        body = json.dumps(q)\n        got = get_series.asyncio(client=self.client, body=body)\n        out.append(got)\n\n    return asyncio.gather(*out)\n</code></pre>"},{"location":"api_docs/#juice_core.SHTRestInterface.expand_column","title":"<code>expand_column(tab: pd.DataFrame, column_name='description') -&gt; pd.DataFrame</code>","text":"<p>Some tables have a description column that contains additional information.</p> <p>This function expands the description column into multiple columns.</p>"},{"location":"api_docs/#juice_core.SHTRestInterface.expand_column--parameters","title":"Parameters","text":"<p>tab (pd.DataFrame):     table to expand, must have a description column</p>"},{"location":"api_docs/#juice_core.SHTRestInterface.expand_column--returns","title":"Returns","text":"<p>pd.DataFrame:     a new dataframe with the description column expanded</p> Source code in <code>src/juice_core/SHTRestInterface.py</code> <pre><code>def expand_column(tab: pd.DataFrame, column_name=\"description\") -&gt; pd.DataFrame:\n    \"\"\"Some tables have a description column that contains additional information.\n\n    This function expands the description column into multiple columns.\n\n    Parameters\n    ----------\n    tab (pd.DataFrame):\n        table to expand, must have a description column\n\n    Returns\n    -------\n    pd.DataFrame:\n        a new dataframe with the description column expanded\n\n    \"\"\"\n    additional_columns = []\n    for d in tab[column_name]:\n        values = {}\n        for item in d.split(\";\"):\n            key, value = item.split(\"=\")\n            values[key.strip()] = value.strip()\n\n        additional_columns.append(values)\n\n    tab_ = tab.drop(columns=[column_name], inplace=False)\n    newd = pd.DataFrame(additional_columns)\n\n    return tab_.join(newd)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0211-2024-10-14","title":"0.2.11 - 2024-10-14","text":""},{"location":"changelog/#0210-2024-10-14","title":"0.2.10 - 2024-10-14","text":""},{"location":"changelog/#029-2024-10-10","title":"0.2.9 - 2024-10-10","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>previous version did not have correct metadata.</li> </ul>"},{"location":"changelog/#028-2024-10-10","title":"0.2.8 - 2024-10-10","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>overall reworking to streamline the generation of the api client.</li> <li>Adopted wolt template (personal fork)</li> </ul>"}]}